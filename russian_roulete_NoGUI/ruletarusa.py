# -*- coding: utf-8 -*-
"""RuletaRusa.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q9IOTTJcQ9wn6p1xziDBeBkmmD6d6UK3
"""

import random
"""
Funciones
"""
#Funcion del juego en modo cooperativo
def pistola_coop_juego(num_Players, balas):
    players = cola_array()
    for i in range(1, num_Players + 1):
        players.enqueue(input(f"Nombre del Jugador {i}: "))
    pistola = PistolaCoop(num_Players, balas)
    actual = players.first()
    while True:
        if players.size == 1:
            print(f"\nGanador: {actual}")
            break
        aux = actual
        pistola.girar()
        print("¡Se rota el tambor!")
        print(f"Turno actual de: {aux}")
        input("Pulse cualquier tecla para disparar...")
        if pistola.tambor.ultimo.siguiente.dato == 1:
            pistola.disparar()
            print(f"Ha perdido: {aux}")
            players.dequeue()
        else:
            pistola.disparar()
            print("Sigue jugando.")
            players.enqueue(players.dequeue())
        actual = players.first()
"""
TDA
"""
class cola_array:
    CAPACIDAD = 4
    def __init__(self):
        self.data = [None] * cola_array.CAPACIDAD
        self.size = 0
        self.front = 0

    def len(self):
        return self.size

    def isEmpty(self):
        return self.size == 0

    def first(self):
        if self.isEmpty():
            return None
        else:
            return self.data[self.front]

    def dequeue(self):
        if self.isEmpty():
            return None
        else:
            aux = self.data[self.front]
            self.data[self.front] = None
            self.front = (self.front + 1) % len(self.data)
            self.size -= 1
            return aux

    def enqueue(self, data):
        if self.size == len(self.data):
            self.resize(2 * len(self.data))
        avail = (self.front + self.size) % len(self.data)
        self.data[avail] = data
        self.size += 1

    def resize(self, capacidad):
        vieja = self.data
        self.data = [None] * capacidad
        frente = self.front
        for k in range(self.size):
            self.data[k] = vieja[frente]
            frente = (1 + frente) % len(vieja)
        self.front = 0

class Nodo:
    def __init__(self, valor):
        self.dato = valor
        self.siguiente = None
class ListaCircular:
    def __init__(self):
        self.ultimo = None
        self.size = 0
    # Método para verificar si la lista está vacía
    def esta_vacia(self):
        return self.ultimo is None
    # Método para insertar un nodo al final de la lista
    def insertar(self, valor):
        nuevo_nodo = Nodo(valor)
        if self.esta_vacia():
            self.ultimo = nuevo_nodo
            nuevo_nodo.siguiente = nuevo_nodo
        else:
            nuevo_nodo.siguiente = self.ultimo.siguiente
            self.ultimo.siguiente = nuevo_nodo
            self.ultimo = nuevo_nodo
        self.size += 1
    def borrado(self, entrada):
        if self.esta_vacia():
            print("La lista está vacía, no se puede eliminar ningún elemento.")
            return
        actual = self.ultimo
        encontrado = False
        while (actual.siguiente != self.ultimo) and (not encontrado):
            encontrado = (actual.siguiente.dato == entrada)
            if not encontrado:
                actual = actual.siguiente
        encontrado = (actual.siguiente.dato == entrada)
        if encontrado:
            p = actual.siguiente
            if self.ultimo == self.ultimo.siguiente:
                self.ultimo = None
            else:
                if p == self.ultimo:
                    self.ultimo = p.siguiente
                actual.siguiente = p.siguiente
            self.size-=1
        else:
            print(f"El dato {entrada} no se encontró en la lista.")
    # Método para mostrar la lista
    def mostrar(self):
        if self.esta_vacia():
            print("La lista está vacía.")
            return
        actual = self.ultimo.siguiente
        while True:
            print(actual.dato, end=" ")
            actual = actual.siguiente
            if actual == self.ultimo.siguiente:
                break
        print()
    # Método para contar los elementos en la lista circular
    def contar_elementos(self):
        if self.esta_vacia():
            return 0
        contador = 0
        actual = self.ultimo.siguiente
        while True:
            contador += 1
            actual = actual.siguiente
            if actual == self.ultimo.siguiente:
                break
        return contador
    def existe_elemento(self, n):
        if self.esta_vacia():
            return False
        actual = self.ultimo.siguiente
        while True:
            if actual.dato == n:
                return True
            actual = actual.siguiente
            if actual == self.ultimo.siguiente:
                break
class Pistola:
    # Clase Pistola que simula un tambor de revólver mediante una lista circular simple (LCS).
    def __init__(self, nmaxP=6):
        self.tambor = self.generar_nodos(nmaxP)
        self.num_espacios_tambor = self.tambor.contar_elementos()  # Se puede quitar el tipo explícito en la asignación.
    def generar_nodos(self, capacidad):
        tambor = ListaCircular()
        for i in range(capacidad):
            tambor.insertar(0)
        return tambor

    def cargar(self, n, nMax=None, nMin=1):
        if nMax is None:
            nMax = self.num_espacios_tambor - 1
        balas_cargadas = 0
        while balas_cargadas < n:
            pasos = random.randint(1, nMax + 1)
            actual = self.tambor.ultimo.siguiente
            for i in range(pasos):
                actual = actual.siguiente
            if actual.dato == 0:
                actual.dato = 1
                balas_cargadas += 1
    def girar(self):

          pasos = random.randint(1, self.num_espacios_tambor + 1)
          actual = self.tambor.ultimo.siguiente
          for _ in range(pasos):
              actual = actual.siguiente
          self.tambor.ultimo = actual
    def contar_balas_cargadas(self):
        if self.tambor.esta_vacia():
            return 0
        contador = 0
        actual = self.tambor.ultimo.siguiente
        while True:
            if (actual.dato == 1):
                contador += 1
            actual = actual.siguiente
            if actual == self.tambor.ultimo.siguiente:
                break
        return contador
    def disparar(self):
        # Simula un disparo
        actual = self.tambor.ultimo.siguiente
        if actual.dato == 1:
            print("¡BANG!")
            actual.dato = 0

        else:
            print("Clic")
        self.tambor.ultimo = actual
class PistolaSolo(Pistola):
    # Variante de Pistola diseñada para un solo jugador.
    def __init__(self, tam_tambor, num_balas):
        super().__init__()
        self.tambor = self.generar_nodos(tam_tambor)
        self.cargar(num_balas, nMax=tam_tambor-1)
class PistolaCoop(Pistola):
    # Variante de Pistola diseñada para un juego cooperativo.
    def __init__(self,jugadores,balas):

        super().__init__()
        self.cargar(balas,nMin=jugadores-1)

"""
MAIN
"""

cic_1 = True
while cic_1:
    try:
        print("Bienvenido a la ruleta rusa!!!!")
        print("""Elija de las siguientes opciones:
        1. Para Single player
        2. Para MultiPlayer
        """)
        opcion = int(input("Opción: "))
        cic_2 = True
        while cic_2:
            match opcion:
                case 1:
                    cic_3 = True
                    print("Bienvenido a la ruleta rusa Single Player!!!!")

                    # Preguntar cuántas pistolas usar
                    tam_tambor = int(input("¿Cuántas pistolas quieres usar? (1-10): "))
                    if tam_tambor > 10:
                        print(f"No se puede usar más de {10} pistolas.")
                        continue
                    elif tam_tambor < 1:
                        print(f"No se puede usar menos de {1} pistolas.")
                        continue

                    # Preguntar cuántas balas cargar
                    balas_cargadas = int(input(f"¿Cuántas balas quieres cargar? (1-{tam_tambor - 1}): "))
                    if balas_cargadas >= tam_tambor or balas_cargadas < 1:
                        print(f"Debes cargar entre 1 y {tam_tambor - 1} balas.")
                        continue

                    # Sacar la creación de la pistola del bucle
                    pistola = PistolaSolo(tam_tambor, balas_cargadas)

                    while cic_3:
                        pistola.tambor.mostrar()
                        print(f"\nHay {tam_tambor} pistolas disponibles.")
                        eleccion = int(input(f"Elige una pistola entre 1 y {tam_tambor}: "))

                        if eleccion < 1 or eleccion > tam_tambor:
                            print(f"Opción no válida. Elige un número entre 1 y {tam_tambor}.")
                            continue

                        print(f"Elegiste la pistola {eleccion}")
                        input("Presiona cualquier tecla para disparar...")

                        actual = pistola.tambor.ultimo.siguiente
                        for i in range(eleccion - 1):
                            actual = actual.siguiente

                        print("¡Dispara!")

                        if actual.dato == 0:
                            print("¡clic")
                            print("¡Sobreviviste! ¿Deseas intentar de nuevo? (S/N)")
                            respuesta = input()
                            cic_3 = respuesta == 's' or respuesta == "S"
                        else:
                            print("!BANG¡")
                            print("¡Moriste!")
                            cic_3 = False
                    cic_2 = False

                case 2:
                    print("Bienvenido a la ruleta rusa de múltiples jugadores!!!!")
                    print("Recordatorio: Una vez empezado, no parará hasta que solo uno esté vivo.")
                    pers = int(input("¿Cuántas personas quieres que jueguen?: "))
                    if pers > 4:
                        print("No se puede cargar más de 4 jugadores.")
                    elif pers < 2:
                        print("No se puede jugar con menos de 2 jugadores.")
                    else:
                        bal = int(input("¿Cuántas balas quieres cargar? :" ))
                        if bal > 5:
                            print("No se puede cargar más de 5 balas.")
                        elif bal < pers - 1:
                            print("No se puede cargar menos de 1 bala.")
                        else:
                            pistola_coop_juego(pers, bal)
                            cic_2 = False
                            cic_3 = False
                case _:
                    print("Opción no estipulada en el catálogo...")

            respuesta = input("Has terminado tu partida, Si deseas continuar, presiona S, si no presiona cualquier tecla otra tecla: ")

            if respuesta.upper() == "S":
                cic_1 = True
            else:
                cic_1 = False
                print("¡Gracias por jugar!!!!!!")
    except ValueError:
        print("Por favor, ingresa un número válido.")